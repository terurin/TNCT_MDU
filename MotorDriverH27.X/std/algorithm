// algorithm standard header
#ifndef _ALGORITHM_
#define _ALGORITHM_
#include <memory>

_STD_BEGIN
		// COMMON SORT PARAMETERS
const int _ISORT_MAX = 32;	// maximum size for insertion sort

		// TEMPLATE FUNCTION for_each
export
template<class _InIt,
	class _Fn1>
	_Fn1 _For_each(_InIt _First, _InIt _Last, _Fn1 _Func);

template<class _InIt,
	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	// perform function for each element
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Func);
	return (_For_each(_Unchecked(_First), _Unchecked(_Last), _Func));
	}

		// TEMPLATE FUNCTION find
export
template<class _InIt,
	class _Ty>
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val);

inline const char *_Find(const char *_First, const char *_Last, int _Val)
	{	// find first char that matches _Val
	_First = (const char *)_CSTD memchr(_First, _Val, _Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const signed char *_Find(const signed char *_First,
	const signed char *_Last, int _Val)
	{	// find first signed char that matches _Val
	_First = (const signed char *)_CSTD memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const unsigned char *_Find(const unsigned char *_First,
	const unsigned char *_Last, int _Val)
	{	// find first unsigned char that matches _Val
	_First = (const unsigned char *)_CSTD memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	// find first matching _Val
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		// TEMPLATE FUNCTION find_if
export
template<class _InIt,
	class _Pr>
	_InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred);

template<class _InIt,
	class _Pr> inline
	_InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// find first satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		// TEMPLATE FUNCTION adjacent_find
export
template<class _FwdIt>
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last);

template<class _FwdIt> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	// find first matching successor
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Adjacent_find(_Unchecked(_First), _Unchecked(_Last))));
	}

		// TEMPLATE FUNCTION adjacent_find WITH PRED
export
template<class _FwdIt,
	class _Pr>
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred);

template<class _FwdIt,
	class _Pr> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find first satisfying _Pred with successor
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Adjacent_find(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		// TEMPLATE FUNCTION count
export
template<class _InIt,
	class _Ty>
	typename iterator_traits<_InIt>::difference_type
		_Count(_InIt _First, _InIt _Last, const _Ty& _Val);

template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	// count elements that match _Val
	_DEBUG_RANGE(_First, _Last);
	return (_Count(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		// TEMPLATE FUNCTION count_if
export
template<class _InIt,
	class _Pr>
	typename iterator_traits<_InIt>::difference_type
		_Count_if(_InIt _First, _InIt _Last, _Pr _Pred);

template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// count elements satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Count_if(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 #if _HAS_CPP0X
		// TEMPLATE FUNCTION all_of
template<class _InIt,
	class _Pr> inline
	bool _All_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if all elements satisfy _Pred
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if all elements satisfy _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_All_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		// TEMPLATE FUNCTION any_of
template<class _InIt,
	class _Pr> inline
	bool _Any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if any element satisfies _Pred
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (true);
	return (false);
	}

template<class _InIt,
	class _Pr> inline
	bool any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if any element satisfies _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Any_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		// TEMPLATE FUNCTION none_of
template<class _InIt,
	class _Pr> inline
	bool _None_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if no elements satisfy _Pred
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool none_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if no elements satisfy _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_None_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		// TEMPLATE FUNCTION find_if_not
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// find first element that satisfies !_Pred
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// find first element that satisfies !_Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Find_if_not(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		// TEMPLATE FUNCTION copy_if
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	// copy each satisfying _Pred
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_Dest++ = *_First;
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	// copy each satisfying _Pred
	return (_Copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, _True_type)
	{	// copy each satisfying _Pred, checked dest
	return (_Copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, _False_type)
	{	// copy each satisfying _Pred, unchecked dest
	return (_Copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	// copy each satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	_DEBUG_POINTER(_Pred);
	return (_STD _Copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *copy_if(_InIt _First, _InIt _Last, _OutTy (&_Dest)[_OutSize],
		_Pr _Pred)
	{	// copy each satisfying _Pred, array dest
	return (_Unchecked(
		_STD copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION partition_copy
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_Dest1++ = *_First;
		else
			*_Dest2++ = *_First;
	return (_STD pair<_OutIt1, _OutIt2>( _Dest1, _Dest2));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++
	return (_STD pair<_OutIt1, _OutIt2>(
		_Partition_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest1, _Dest2, _Pred)));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			_True_type, _True_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, checked dest
	return (_STD pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			_True_type, _False_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, unchecked dest
	return (_STD pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			_False_type, _True_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, unchecked dest
	return (_STD pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			_False_type, _False_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, unchecked dest
	return (_STD pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest1);
	_DEBUG_POINTER(_Dest2);
	_DEBUG_POINTER(_Pred);
	return (_STD pair<_OutIt1, _OutIt2>(
		_STD _Partition_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest1, _Dest2, _Pred,
			_Is_checked(_Dest1), _Is_checked(_Dest2))));
	}

template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutIt2,
	class _Pr> inline
	_STD pair<_OutTy1 *, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++, array dest
	_STD pair<_Array_iterator<_OutTy1, _OutSize1>, _OutIt2> _Ans =
		_STD partition_copy(_First, _Last,
			_Array_iterator<_OutTy1, _OutSize1>(_Dest1), _Dest2, _Pred);
	return (_STD pair<_OutTy1 *, _OutIt2>(
		_Unchecked(_Ans.first),
		_Ans.second));
	}

template<class _InIt,
	class _OutIt1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	_STD pair<_OutIt1, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutTy2 (&_Dest2)[_OutSize2], _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++, array dest
	_STD pair<_OutIt1, _Array_iterator<_OutTy2, _OutSize2> > _Ans =
		_STD partition_copy(_First, _Last,
			_Dest1, _Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred);
	return (_STD pair<_OutIt1, _OutTy2 *>(
		_Ans.first,
		_Unchecked(_Ans.second)));
	}

template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	_STD pair<_OutTy1 *, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutTy2 (&_Dest2)[_OutSize2],
			_Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++, array dest
	_STD pair<_Array_iterator<_OutTy1, _OutSize1>,
		_Array_iterator<_OutTy2, _OutSize2> > _Ans =
			_STD partition_copy(_First, _Last,
				_Array_iterator<_OutTy1, _OutSize1>(_Dest1),
				_Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred);
	return (_STD pair<_OutTy1 *, _OutTy2 *>(
		_Unchecked(_Ans.first),
		_Unchecked(_Ans.second)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION is_partitioned
template<class _InIt,
	class _Pr> inline
	bool _Is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if [_First, _Last) partitioned by _Pred
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;	// skip true partition
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);	// found out of place element
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if [_First, _Last) partitioned by _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Is_partitioned(_Unchecked(_First), _Unchecked(_Last),
		_Pred));
	}

		// TEMPLATE FUNCTION partition_point
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find beginning of false partition in [_First, _Last)
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;	// skip true partition
	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find beginning of false partition in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Partition_point(_Unchecked(_First), _Unchecked(_Last),
			_Pred)));
	}
 #endif /* _HAS_CPP0X */

		// TEMPLATE FUNCTION search
export
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2>
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *);

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// find first [_First2, _Last2) match
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Rechecked(_First1,
		_Search(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2),
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		// TEMPLATE FUNCTION search WITH PRED
export
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr>
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *);

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// find first [_First2, _Last2) satisfying _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First1,
		_Search(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		// TEMPLATE FUNCTION search_n
export
template<class _FwdIt1,
	class _Diff2,
	class _Ty>
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, forward_iterator_tag);

export
template<class _FwdIt1,
	class _Diff2,
	class _Ty>
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, random_access_iterator_tag);

template<class _FwdIt1,
	class _Diff2,
	class _Ty> inline
	_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val)
	{	// find first _Count * _Val match
	_DEBUG_RANGE(_First1, _Last1);
	return (_Rechecked(_First1,
		_Search_n(_Unchecked(_First1), _Unchecked(_Last1), _Count, _Val,
			_Iter_cat(_First1))));
	}

		// TEMPLATE FUNCTION search_n WITH PRED
export
template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr>
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag);

export
template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr>
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag);

template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr> inline
	_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred)
	{	// find first _Count * _Val satisfying _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First1,
		_Search_n(_Unchecked(_First1), _Unchecked(_Last1), _Count, _Val,
			_Pred, _Iter_cat(_First1))));
	}

		// TEMPLATE FUNCTION find_end
export
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2>
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *);

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// find last [_First2, _Last2) match
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Rechecked(_First1,
		_Find_end(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2),
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		// TEMPLATE FUNCTION find_end WITH PRED
export
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr>
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *);

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// find last [_First2, _Last2) satisfying _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First1,
		_Find_end(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		// TEMPLATE FUNCTION find_first_of
export
template<class _FwdIt1,
	class _FwdIt2>
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2);

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// look for one of [_First2, _Last2) that matches element
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Rechecked(_First1,
		_Find_first_of(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2))));
	}

		// TEMPLATE FUNCTION find_first_of WITH PRED
export
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred);

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// look for one of [_First2, _Last2) satisfying _Pred with element
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First1,
		_Find_first_of(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

		// TEMPLATE FUNCTION swap_ranges
export
template<class _FwdIt1,
	class _FwdIt2>
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	// swap [_First1, _Last1) with [_Dest, ...)
	return (_Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest,
		forward_iterator_tag, forward_iterator_tag)
	{	// swap [_First1, _Last1) with [_Dest, ...), arbitrary iterators
	return (_Swap_ranges(_First1, _Last1,
		_Dest));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// swap [_First1, _Last1) with [_Dest, ...), random-access iterators
	_FwdIt2 _Ans = _Dest + (_Last1 - _First1);	// also checks range
	_Swap_ranges(_First1, _Last1,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest, _True_type)
	{	// swap [_First1, _Last1) with [_Dest, ...), checked dest
	return (_Swap_ranges(_First1, _Last1,
		_Dest, _Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest, _False_type)
	{	// swap [_First1, _Last1) with [_Dest, ...), unchecked dest
	return (_Swap_ranges(_First1, _Last1,
		_Dest, _Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	// swap [_First1, _Last1) with [_Dest, ...)
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_Dest);
	return (_STD _Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
		_Dest, _Is_checked(_Dest)));
	}

template<class _FwdIt1,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_OutTy (&_Dest)[_OutSize])
	{	// swap [_First1, _Last1) with [_Dest, ...), array dest
	return (_Unchecked(
		_STD swap_ranges(_First1, _Last1,
		_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION swap
template<class _Ty,
	size_t _Size> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
	{	// exchange arrays stored at _Left and _Right
	if (&_Left != &_Right)
		_Swap_ranges(&_Left[0], &_Left[0] + _Size, &_Right[0]);
	}

		// TEMPLATE FUNCTION transform WITH UNARY OP
export
template<class _InIt,
	class _OutIt,
	class _Fn1>
	_OutIt _Transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	// transform [_First, _Last) with _Func
	if (_First != _Last)
		return (_Transform(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Func));
	return (_Dest);
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func,
		input_iterator_tag, output_iterator_tag)
	{	// transform [_First, _Last) with _Func, arbitrary iterators
	return (_Transform(_First, _Last,
		_Dest, _Func));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// transform [_First, _Last) with _Func, random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Transform(_First, _Last,
		_Unchecked(_Dest), _Func);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func, _True_type)
	{	// transform [_First, _Last) with _Func, checked dest
	return (_Transform1(_First, _Last,
		_Dest, _Func,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func, _False_type)
	{	// transform [_First, _Last) with _Func, unchecked dest
	return (_Transform1(_First, _Last,
		_Dest, _Func,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	// transform [_First, _Last) with _Func
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	_DEBUG_POINTER(_Func);
	if (_First != _Last)
		return (_Transform1(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Func, _Is_checked(_Dest)));
	return (_Dest);
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Fn1> inline
	_OutTy *transform(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Fn1 _Func)
	{	// transform [_First, _Last) with _Func, array dest
	return (_Unchecked(
		_STD transform(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION transform WITH BINARY OP
export
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2>
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...) with _Func
	if (_First1 != _Last1)
		return (_Transform(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Dest, _Func));
	return (_Dest);
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform3(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		input_iterator_tag, output_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), arbitrary dest
	return (_Transform(_First1, _Last1,
		_First2, _Dest, _Func));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform3(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), random-access dest
	_OutIt _Ans = _Dest + (_Last1 - _First1);	// also checks range
	_Transform(_First1, _Last1,
		_First2, _Unchecked(_Dest), _Func);
	return (_Ans);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		input_iterator_tag, input_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), arbitrary input
	return (_Transform3(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), random-access input
	_InIt2 _Last2 = _First2 + (_Last1 - _First1);	// also checks range
	_Last2 = _Last2;	// to quiet diagnostics
	return (_Transform3(_First1, _Last1,
		_Unchecked(_First2), _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		_True_type)
	{	// transform [_First1, _Last1) and [_First2, ...), checked dest
	return (_Transform2(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		_False_type)
	{	// transform [_First1, _Last1) and [_First2, ...), unchecked dest
	return (_Transform2(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...) with _Func
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_Dest);
	_DEBUG_POINTER(_Func);
	if (_First1 != _Last1)
		return (_Transform2(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Dest, _Func,
			_Is_checked(_Dest)));
	return (_Dest);
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array input
	return (_STD transform(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Dest, _Func));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array dest
	return (_Unchecked(
		_STD transform(_First1, _Last1,
			_First2, _Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array input/dest
	return (_Unchecked(
		_STD transform(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2),
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION replace
export
template<class _FwdIt,
	class _Ty>
	void _Replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval);

template<class _FwdIt,
	class _Ty> inline
	void replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	// replace each matching _Oldval with _Newval
	_DEBUG_RANGE(_First, _Last);
	_Replace(_Unchecked(_First), _Unchecked(_Last),
		_Oldval, _Newval);
	}

		// TEMPLATE FUNCTION replace_if
export
template<class _FwdIt,
	class _Pr,
	class _Ty>
	void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val);

template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	// replace each satisfying _Pred with _Val
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	_Replace_if(_Unchecked(_First), _Unchecked(_Last),
		_Pred, _Val);
	}

		// TEMPLATE FUNCTION replace_copy
export
template<class _InIt,
	class _OutIt,
	class _Ty>
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		input_iterator_tag, output_iterator_tag)
	{	// copy replacing each matching _Oldval, arbitrary iterators
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy replacing each matching _Oldval, random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Replace_copy(_First, _Last,
		_Unchecked(_Dest), _Oldval, _Newval);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		_True_type)
	{	// copy replacing each matching _Oldval with _Newval, checked dest
	return (_Replace_copy(_First, _Last,
		_Dest, _Oldval, _Newval,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		_False_type)
	{	// copy replacing each matching _Oldval with _Newval, unchecked dest
	return (_Replace_copy(_First, _Last,
		_Dest, _Oldval, _Newval,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *replace_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval, array dest
	return (_Unchecked(
		_STD replace_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Oldval, _Newval)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION replace_copy_if
export
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty>
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val
	return (_Replace_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Val));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		input_iterator_tag, output_iterator_tag)
	{	// copy replacing each satisfying _Pred, arbitrary iterators
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy replacing each satisfying _Pred, random_access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Replace_copy_if(_First, _Last,
		_Unchecked(_Dest), _Pred, _Val);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		_True_type)
	{	// copy replacing each satisfying _Pred with _Val, checked dest
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		_False_type)
	{	// copy replacing each satisfying _Pred with _Val, unchecked dest
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	_DEBUG_POINTER(_Pred);
	return (_Replace_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Val,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr,
	class _Ty> inline
	_OutTy *replace_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val, array dest
	return (_Unchecked(
		_STD replace_copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred, _Val)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION generate
export
template<class _FwdIt,
	class _Fn0>
	void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func);

template<class _FwdIt,
	class _Fn0> inline
	void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	// replace [_First, _Last) with _Func()
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Func);
	_Generate(_Unchecked(_First), _Unchecked(_Last), _Func);
	}

		// TEMPLATE FUNCTION generate_n
export
template<class _OutIt,
	class _Diff,
	class _Fn0>
	void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	void generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func()
	_Generate_n(_Dest, _Count, _Func);
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	void _Generate_n1(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		output_iterator_tag)
	{	// replace [_Dest, _Dest + _Count), arbitrary iterators
	_Generate_n(_Dest, _Count, _Func);
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	void _Generate_n1(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		random_access_iterator_tag)
	{	// replace [_Dest, _Dest + _Count), random-access iterators
	_OutIt _Ans = _Dest + _Count;	// also checks range
	_Ans = _Ans;	// to quiet diagnostics
	_Generate_n(_Unchecked(_Dest), _Count, _Func);
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		_True_type)
	{	// replace [_Dest, _Dest + _Count) with _Func(), checked dest
	_Generate_n1(_Dest, _Count, _Func,
		_Iter_cat(_Dest));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		_False_type)
	{	// replace [_Dest, _Dest + _Count) with _Func(), unchecked dest
	_Generate_n1(_Dest, _Count, _Func,
		_Iter_cat(_Dest));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	void generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func()
	_DEBUG_POINTER(_Dest);
	_DEBUG_POINTER(_Func);
	_Generate_n(_Dest, _Count, _Func,
		_Is_checked(_Dest));
	}

template<class _OutTy,
	size_t _OutSize,
	class _Diff,
	class _Fn0> inline
	void generate_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, _Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func(), array dest
	_STD generate_n(_Array_iterator<_OutTy, _OutSize>(_Dest), _Count, _Func);
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION remove_copy
export
template<class _InIt,
	class _OutIt,
	class _Ty>
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	// copy omitting each matching _Val
	return (_Remove_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Val));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val,
		_True_type)
	{	// copy omitting each matching _Val, checked dest
	return (_Remove_copy(_First, _Last,
		_Dest, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val,
		_False_type)
	{	// copy omitting each matching _Val, unchecked dest
	return (_Remove_copy(_First, _Last,
		_Dest, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	// copy omitting each matching _Val
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_Remove_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Val,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *remove_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Val)
	{	// copy omitting each matching _Val, array dest
	return (_Unchecked(
		_STD remove_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Val)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION remove_copy_if
export
template<class _InIt,
	class _OutIt,
	class _Pr>
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy omitting each element satisfying _Pred
	return (_Remove_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred,
		_True_type)
	{	// copy omitting each element satisfying _Pred, checked dest
	return (_Remove_copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred,
		_False_type)
	{	// copy omitting each element satisfying _Pred, unchecked dest
	return (_Remove_copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy omitting each element satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	_DEBUG_POINTER(_Pred);
	return (_Remove_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *remove_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// copy omitting each element satisfying _Pred, array dest
	return (_Unchecked(
		_STD remove_copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION remove
export
template<class _FwdIt,
	class _Ty>
	_FwdIt _Remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val);

template<class _FwdIt,
	class _Ty> inline
	_FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// remove each matching _Val
	_First = _STD find(_First, _Last, _Val);
	if (_First == _Last)
		return (_First);	// empty sequence, all done
	else
		return (_Rechecked(_First,
			_Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		// TEMPLATE FUNCTION remove_if
export
template<class _FwdIt,
	class _Pr>
	_FwdIt _Remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred);

template<class _FwdIt,
	class _Pr> inline
	_FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// remove each satisfying _Pred
	_First = _STD find_if(_First, _Last, _Pred);
	if (_First == _Last)
		return (_First);	// empty sequence, all done
	else
		return (_Rechecked(_First,
			_Remove_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		// TEMPLATE FUNCTION unique
export
template<class _FwdIt>
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last);

template<class _FwdIt> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{	// remove each matching previous
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Unique(_Unchecked(_First), _Unchecked(_Last))));
	}

		// TEMPLATE FUNCTION unique WITH PRED
export
template<class _FwdIt,
	class _Pr>
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred);

template<class _FwdIt,
	class _Pr> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// remove each satisfying _Pred with previous
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Unique(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		// TEMPLATE FUNCTION unique_copy
export
template<class _InIt,
	class _OutIt,
	class _Ty>
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Ty *);

template<class _InIt,
	class _OutIt> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag)
	{	// copy compressing pairs that match, input iterators
	return (_Unique_copy(_First, _Last, _Dest,
		_Val_type(_First)));
	}

export
template<class _FwdIt,
	class _OutIt>
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, forward_iterator_tag);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy compressing pairs that match
	return (_First == _Last ? _Dest :
		_Unique_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Iter_cat(_First)));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt> inline
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _True_type)
	{	// copy compressing pairs that match, checked dest
	return (_Unique_copy(_First, _Last,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _False_type)
	{	// copy compressing pairs that match, unchecked dest
	return (_Unique_copy(_First, _Last,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy compressing pairs that match
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_First == _Last ? _Dest :
		_Unique_copy1(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy compressing pairs that match, array dest
	return (_Unchecked(
		_STD unique_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION unique_copy WITH PRED
export
template<class _InIt,
	class _OutIt,
	class _Ty,
	class _Pr>
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, _Ty *);

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, input_iterator_tag)
	{	// copy compressing pairs satisfying _Pred, input iterators
	return (_Unique_copy(_First, _Last, _Dest, _Pred,
		_Val_type(_First)));
	}

export
template<class _FwdIt,
	class _OutIt,
	class _Pr>
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, _Pr _Pred, forward_iterator_tag);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy compressing pairs that match
	return (_First == _Last ? _Dest :
		_Unique_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Pred, _Iter_cat(_First)));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, _True_type)
	{	// copy compressing pairs that match, checked dest
	return (_Unique_copy(_First, _Last,
		_Dest, _Pred, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, _False_type)
	{	// copy compressing pairs that match, unchecked dest
	return (_Unique_copy(_First, _Last,
		_Dest, _Pred, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy compressing pairs that match
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_First == _Last ? _Dest :
		_Unique_copy1(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// copy compressing pairs that match, array dest
	return (_Unchecked(
		_STD unique_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION reverse_copy
export
template<class _BidIt,
	class _OutIt>
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	// copy reversing elements in [_First, _Last)
	return (_Reverse_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		input_iterator_tag, output_iterator_tag)
	{	// copy reversing elements in [_First, _Last), arbitrary iterators
	return (_Reverse_copy(_First, _Last,
		_Dest));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy reversing elements in [_First, _Last), random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Reverse_copy(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		_True_type)
	{	// copy reversing elements in [_First, _Last), checked dest
	return (_Reverse_copy(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		_False_type)
	{	// copy reversing elements in [_First, _Last), unchecked dest
	return (_Reverse_copy(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	// copy reversing elements in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_Reverse_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

template<class _BidIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *reverse_copy(_BidIt _First, _BidIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy reversing elements in [_First, _Last), array dest
	return (_Unchecked(
		_STD reverse_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION rotate_copy
template<class _FwdIt,
	class _OutIt> inline
	_OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest)
	{	// copy rotating [_First, _Last)
	_Dest = _STD copy(_Mid, _Last, _Dest);
	return (_STD copy(_First, _Mid, _Dest));
	}

		// TEMPLATE FUNCTION random_shuffle
export
template<class _RanIt,
	class _Diff>
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Diff *);

template<class _RanIt> inline
	void random_shuffle(_RanIt _First, _RanIt _Last)
	{	// shuffle [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	if (_First != _Last)
		_Random_shuffle(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First));
	}

		// TEMPLATE FUNCTION random_shuffle WITH RANDOM FN
template<class _RanIt,
	class _Fn1,
	class _Diff> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func, _Diff *)
	{	// shuffle nonempty [_First, _Last) using random function _Func
	_RanIt _Next = _First;
	for (_Diff _Index = 2; ++_Next != _Last; ++_Index)
		_STD iter_swap(_Next, _First + _Diff(_Func(_Index) % _Index));
	}

template<class _RanIt,
	class _Fn1> inline
	void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func)
	{	// shuffle [_First, _Last) using random function _Func
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Func);
	if (_First != _Last)
		_Random_shuffle(_Unchecked(_First), _Unchecked(_Last), _Func,
			_Dist_type(_First));
	}

		// TEMPLATE FUNCTION partition
export
template<class _BidIt,
	class _Pr>
	_BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred);

template<class _BidIt,
	class _Pr> inline
	_BidIt partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// move elements satisfying _Pred to beginning of sequence
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Partition(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		// TEMPLATE FUNCTION stable_partition
export
template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty>
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff _Count, _Temp_iterator<_Ty>& _Tempbuf);

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	// partition preserving order of equivalents, using _Pred
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf(_Count);
	return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// partition preserving order of equivalents, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_First == _Last ? _First
		: _Rechecked(_First,
			_Stable_partition(_Unchecked(_First), _Unchecked(_Last),
				_Pred, _Dist_type(_First), _Val_type(_First))));
	}

 #if _ITERATOR_DEBUG_LEVEL == 2
		// TEMPLATE FUNCTION _Debug_heap
template<class _RanIt> inline
	void _Debug_heap(_RanIt _First, _RanIt _Last)
	{	// test if range is a heap ordered by operator<
	if (_First != _Last)
		for (_RanIt _Root = _First; ++_First != _Last; ++_Root)
			if (_DEBUG_LT(*_Root, *_First))
				_DEBUG_ERROR("invalid heap");
			else if (++_First == _Last)
				break;
			else if (_DEBUG_LT(*_Root, *_First))
				_DEBUG_ERROR("invalid heap");
	}

		// TEMPLATE FUNCTION _Debug_heap WITH PRED
template<class _RanIt,
	class _Pr> inline
	void _Debug_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// test if range is a heap ordered by _Pred
	if (_First != _Last)
		for (_RanIt _Root = _First; ++_First != _Last; ++_Root)
			if (_DEBUG_LT_PRED(_Pred, *_Root, *_First))
				_DEBUG_ERROR("invalid heap");
			else if (++_First == _Last)
				break;
			else if (_DEBUG_LT_PRED(_Pred, *_Root, *_First))
				_DEBUG_ERROR("invalid heap");
	}

  #define _DEBUG_HEAP(first, last)	\
	_Debug_heap(_Unchecked(first), _Unchecked(last))
  #define _DEBUG_HEAP_PRED(first, last, pred)	\
	_Debug_heap(_Unchecked(first), _Unchecked(last), pred)

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
  #define _DEBUG_HEAP(first, last)
  #define _DEBUG_HEAP_PRED(first, last, pred)
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

		// TEMPLATE FUNCTION push_heap
export
template<class _RanIt,
	class _Diff,
	class _Ty>
	void _Push_heap(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty _VALREF _Val);

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
	{	// push *_Last onto heap at [_First, _Last), using operator<
	_Diff _Count = _Last - _First;
	if (0 < _Count)
		{	// worth doing, percolate *_Last
		_Ty _Val = _Move(*_Last);
		_Push_heap(_First, _Count, _Diff(0), _Move(_Val));
		}
	}

template<class _RanIt> inline
	void push_heap(_RanIt _First, _RanIt _Last)
	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using operator<
	_DEBUG_RANGE(_First, _Last);
	if (_First != _Last)
		{	// check and push to nontrivial heap
		--_Last;
		_DEBUG_HEAP(_First, _Last);
		_Push_heap_0(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
		}
	}

		// TEMPLATE FUNCTION push_heap WITH PRED
export
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr>
	void _Push_heap(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty _VALREF _Val, _Pr _Pred);

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
	{	// push *_Last onto heap at [_First, _Last), using _Pred
	_Diff _Count = _Last - _First;
	if (0 < _Count)
		{	// worth doing, percolate *_Last
		_Ty _Val = _Move(*_Last);
		_Push_heap(_First, _Count, _Diff(0), _Move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	if (_First != _Last)
		{	// check and push to nontrivial heap
		--_Last;
		_DEBUG_HEAP_PRED(_First, _Last, _Pred);
		_Push_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
		}
	}

		// TEMPLATE FUNCTION pop_heap
export
template<class _RanIt,
	class _Diff,
	class _Ty>
	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
		_Ty _VALREF _Val);

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty _VALREF _Val, _Diff *)
	{	// pop *_First to *_Dest and reheap, using operator<
	*_Dest = _Move(*_First);
	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
		_Move(_Val));
	}

template<class _RanIt,
	class _Ty> inline
	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty *)
	{	// pop *_First to *(_Last - 1) and reheap, using operator<
	_Ty _Val = _Move(*(_Last - 1));
	_Pop_heap(_First, _Last - 1, _Last - 1,
		_Move(_Val), _Dist_type(_First));
	}

template<class _RanIt> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last)
	{	// pop *_First to *(_Last - 1) and reheap, using operator<
	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last),
		_Val_type(_First));
	}

template<class _RanIt> inline
	void pop_heap(_RanIt _First, _RanIt _Last)
	{	// pop *_First to *(_Last - 1) and reheap, using operator<
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_HEAP(_First, _Last);
	if (1 < _Last - _First)
		_Pop_heap(_Unchecked(_First), _Unchecked(_Last));
	}

		// TEMPLATE FUNCTION pop_heap WITH PRED
export
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr>
	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
		_Ty _VALREF _Val, _Pr _Pred);

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty _VALREF _Val, _Pr _Pred, _Diff *)
	{	// pop *_First to *_Dest and reheap, using _Pred
	*_Dest = _Move(*_First);
	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
		_Move(_Val), _Pred);
	}

template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
	_Ty _Val = _Move(*(_Last - 1));
	_Pop_heap(_First, _Last - 1, _Last - 1,
		_Move(_Val), _Pred, _Dist_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
		_Val_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
	if (1 < _Last - _First)
		_Pop_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		// TEMPLATE FUNCTION make_heap
export
template<class _RanIt,
	class _Diff,
	class _Ty>
	void _Make_heap(_RanIt _First, _RanIt _Last, _Diff *, _Ty *);

template<class _RanIt> inline
	void make_heap(_RanIt _First, _RanIt _Last)
	{	// make [_First, _Last) into a heap, using operator<
	_DEBUG_RANGE(_First, _Last);
	if (1 < _Last - _First)
		_Make_heap(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		// TEMPLATE FUNCTION make_heap WITH PRED
export
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr>
	void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *);

template<class _RanIt,
	class _Pr> inline
	void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// make [_First, _Last) into a heap, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	if (1 < _Last - _First)
		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		// TEMPLATE FUNCTION sort_heap
export
template<class _RanIt>
	void _Sort_heap(_RanIt _First, _RanIt _Last);

template<class _RanIt> inline
	void sort_heap(_RanIt _First, _RanIt _Last)
	{	// order heap by repeatedly popping, using operator<
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_HEAP(_First, _Last);
	_Sort_heap(_Unchecked(_First), _Unchecked(_Last));
	}

		// TEMPLATE FUNCTION sort_heap WITH PRED
export
template<class _RanIt,
	class _Pr>
	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred);

template<class _RanIt,
	class _Pr> inline
	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// order heap by repeatedly popping, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		// TEMPLATE FUNCTION lower_bound
export
template<class _FwdIt,
	class _Ty,
	class _Diff>
	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *);

template<class _FwdIt,
	class _Ty> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// find first element not before _Val, using operator<
//	_DEBUG_ORDER(_First, _Last);
	return (_Rechecked(_First,
		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val,
			_Dist_type(_First))));
	}

		// TEMPLATE FUNCTION lower_bound WITH PRED
export
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr>
	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *);

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	// find first element not before _Val, using _Pred
//	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
	return (_Rechecked(_First,
		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
			_Dist_type(_First))));
	}

		// TEMPLATE FUNCTION upper_bound
export
template<class _FwdIt,
	class _Ty,
	class _Diff>
	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *);

template<class _FwdIt,
	class _Ty> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// find first element that _Val is before, using operator<
//	_DEBUG_ORDER(_First, _Last);
	return (_Rechecked(_First,
		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val,
			_Dist_type(_First))));
	}

		// TEMPLATE FUNCTION upper_bound WITH PRED
export
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr>
	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *);

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	// find first element that _Val is before, using _Pred
//	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
	return (_Rechecked(_First,
		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
			_Dist_type(_First))));
	}

		// TEMPLATE FUNCTION equal_range
export
template<class _FwdIt,
	class _Ty,
	class _Diff>
	_STD pair<_FwdIt, _FwdIt>
		_Equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Diff *);

template<class _FwdIt,
	class _Ty> inline
	_STD pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val)
	{	// find range equivalent to _Val, using operator<
	_DEBUG_ORDER(_First, _Last);
	_STD pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
			_Val, _Dist_type(_First)));
	return (_STD pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		// TEMPLATE FUNCTION equal_range WITH PRED
export
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr>
	_STD pair<_FwdIt, _FwdIt>
		_Equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr _Pred, _Diff *);

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_STD pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr _Pred)
	{	// find range equivalent to _Val, using _Pred
	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
	_STD pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
			_Val, _Pred, _Dist_type(_First)));
	return (_STD pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		// TEMPLATE FUNCTION binary_search
template<class _FwdIt,
	class _Ty> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// test if _Val equivalent to some element, using operator<
	_First = _STD lower_bound(_First, _Last, _Val);
	return (_First != _Last && !(_Val < *_First));
	}

		// TEMPLATE FUNCTION binary_search WITH PRED
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	// test if _Val equivalent to some element, using _Pred
	_First = _STD lower_bound(_First, _Last, _Val, _Pred);
	return (_First != _Last && !_Pred(_Val, *_First));
	}

		// TEMPLATE FUNCTION merge
export
template<class _InIt1,
	class _InIt2,
	class _OutIt>
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// copy merging ranges, both using operator<
	return (_Merge(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Merge1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, input_iterator_tag,
		input_iterator_tag, output_iterator_tag)
	{	// copy merging ranges, both using operator<, arbitrary iterators
	return (_Merge(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Merge1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, random_access_iterator_tag,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy merging ranges, both using operator<, random-access iterators
	_OutIt _Ans = _Dest + (_Last1 - _First1)
		+ (_Last2 - _First2);	// also checks range
	_Merge(_First1, _Last1,
		_First2, _Last2,
		_Dest);
	return (_Ans);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Merge1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _True_type)
	{	// copy merging ranges, both using operator<, checked dest
	return (_Merge1(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Merge1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _False_type)
	{	// copy merging ranges, both using operator<, unchecked dest
	return (_Merge1(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// copy merging ranges, both using operator<
	_DEBUG_ORDER(_First1, _Last1);
	_DEBUG_ORDER(_First2, _Last2);
	_DEBUG_POINTER(_Dest);
	return (_Merge1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	// copy merging ranges, both using operator<, array dest
	return (_Unchecked(
		_STD merge(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION merge WITH PRED
export
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr>
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// copy merging ranges, both using _Pred
	return (_Merge(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
		input_iterator_tag, output_iterator_tag)
	{	// copy merging ranges, both using _Pred, arbitrary iterators
	return (_Merge(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy merging ranges, both using _Pred, random-access iterators
	_OutIt _Ans = _Dest + (_Last1 - _First1)
		+ (_Last2 - _First2);	// also checks range
	_Merge(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred);
	return (_Ans);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _True_type)
	{	// copy merging ranges, both using _Pred, checked dest
	return (_Merge2(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _False_type)
	{	// copy merging ranges, both using _Pred, unchecked dest
	return (_Merge2(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// copy merging ranges, both using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER(_Dest);
	_DEBUG_POINTER(_Pred);
	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// copy merging ranges, both using _Pred, array dest
	return (_Unchecked(
		_STD merge(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION inplace_merge
export
template<class _BidIt,
	class _Diff,
	class _Ty>
	_BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf);

export
template<class _BidIt1,
	class _BidIt2,
	class _BidIt3>
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest);

export
template<class _BidIt,
	class _Diff,
	class _Ty>
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf);

export
template<class _BidIt,
	class _Diff,
	class _Ty>
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff *, _Ty *);

template<class _BidIt> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
	_DEBUG_ORDER(_First, _Mid);
	_DEBUG_ORDER(_Mid, _Last);
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(
			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		// TEMPLATE FUNCTION inplace_merge WITH PRED
export
template<class _BidIt1,
	class _BidIt2,
	class _BidIt3,
	class _Pr>
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred);

export
template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr>
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred);

export
template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr>
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *);

template<class _BidIt,
	class _Pr> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
	_DEBUG_ORDER_PRED(_First, _Mid, _Pred);
	_DEBUG_ORDER_PRED(_Mid, _Last, _Pred);
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(
			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		// TEMPLATE FUNCTION sort
export
template<class _BidIt,
	class _Ty>
	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Ty *);

template<class _BidIt> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last)
	{	// insertion sort [_First, _Last), using operator<
	_Insertion_sort1(_First, _Last, _Val_type(_First));
	}

template<class _RanIt> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	// sort median of three elements to middle
	if (_DEBUG_LT(*_Mid, *_First))
		_STD iter_swap(_Mid, _First);
	if (_DEBUG_LT(*_Last, *_Mid))
		_STD iter_swap(_Last, _Mid);
	if (_DEBUG_LT(*_Mid, *_First))
		_STD iter_swap(_Mid, _First);
	}

template<class _RanIt> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	// sort median element to middle
	if (40 < _Last - _First)
		{	// median of nine
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last);
		_Med3(_First + _Step, _Mid, _Last - _Step);
		}
	else
		_Med3(_First, _Mid, _Last);
	}

export
template<class _RanIt>
	_STD pair<_RanIt, _RanIt>
		_Unguarded_partition(_RanIt _First, _RanIt _Last);

export
template<class _RanIt,
	class _Diff>
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal);

template<class _RanIt> inline
	void sort(_RanIt _First, _RanIt _Last)
	{	// order [_First, _Last), using operator<
	_DEBUG_RANGE(_First, _Last);
	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First);
	}

		// TEMPLATE FUNCTION sort WITH PRED
export
template<class _BidIt,
	class _Pr,
	class _Ty>
	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *);

template<class _BidIt,
	class _Pr> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// insertion sort [_First, _Last), using _Pred
	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// sort median of three elements to middle
	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
		_STD iter_swap(_Mid, _First);
	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))
		_STD iter_swap(_Last, _Mid);
	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
		_STD iter_swap(_Mid, _First);
	}

template<class _RanIt,
	class _Pr> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// sort median element to middle
	if (40 < _Last - _First)
		{	// median of nine
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
		}
	else
		_Med3(_First, _Mid, _Last, _Pred);
	}

export
template<class _RanIt,
	class _Pr>
	_STD pair<_RanIt, _RanIt>
		_Unguarded_partition(_RanIt _First, _RanIt _Last, _Pr _Pred);

export
template<class _RanIt,
	class _Diff,
	class _Pr>
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred);

template<class _RanIt,
	class _Pr> inline
	void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// order [_First, _Last), using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);
	}

		// TEMPLATE FUNCTION stable_sort
export
template<class _BidIt,
	class _OutIt,
	class _Diff>
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count);

export
template<class _BidIt,
	class _Diff,
	class _Ty>
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf);

export
template<class _BidIt,
	class _Diff,
	class _Ty>
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf);

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *)
	{	// sort preserving order of equivalents, using operator<
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf);
	}

template<class _BidIt> inline
	void stable_sort(_BidIt _First, _BidIt _Last)
	{	// sort preserving order of equivalents, using operator<
	_DEBUG_RANGE(_First, _Last);
	if (_First != _Last)
		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		// TEMPLATE FUNCTION stable_sort WITH PRED
export
template<class _BidIt,
	class _OutIt,
	class _Diff,
	class _Pr>
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred);

export
template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr>
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred);

export
template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr>
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred);

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	if (_First != _Last)
		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First), _Pred);
	}

		// TEMPLATE FUNCTION partial_sort
export
template<class _RanIt,
	class _Ty>
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty *);

template<class _RanIt> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	// order [First, _Last) up to _Mid, using operator<
	_Partial_sort(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
		_Val_type(_First));
	}

		// TEMPLATE FUNCTION partial_sort WITH PRED
export
template<class _RanIt,
	class _Ty,
	class _Pr>
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		_Pr _Pred, _Ty *);

template<class _RanIt,
	class _Pr> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// order [First, _Last) up to _Mid, using _Pred
	_Partial_sort(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
		_Val_type(_First));
	}

		// TEMPLATE FUNCTION partial_sort_copy
export
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty>
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Diff *, _Ty *);

template<class _InIt,
	class _RanIt> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2)
	{	// copy [First1, _Last1) into [_First2, _Last2), using operator<
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_First1 == _Last1 || _First2 == _Last2 ? _First2
		: _Rechecked(_First2,
			_Partial_sort_copy(
				_Unchecked(_First1), _Unchecked(_Last1),
				_Unchecked(_First2), _Unchecked(_Last2),
				_Dist_type(_First2), _Val_type(_First1))));
	}

		// TEMPLATE FUNCTION partial_sort_copy WITH PRED
export
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr>
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *);

template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{	// copy [First1, _Last1) into [_First2, _Last2) using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER(_Pred);
	return (_First1 == _Last1 || _First2 == _Last2 ? _First2
		: _Rechecked(_First2,
			_Partial_sort_copy(
				_Unchecked(_First1), _Unchecked(_Last1),
				_Unchecked(_First2), _Unchecked(_Last2), _Pred,
				_Dist_type(_First2), _Val_type(_First1))));
	}

		// TEMPLATE FUNCTION nth_element
export
template<class _RanIt>
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last);

template<class _RanIt> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	// order Nth element, using operator<
	_DEBUG_RANGE(_First, _Last);
	_Nth_element(
		_Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last));
	}

		// TEMPLATE FUNCTION nth_element WITH PRED
export
template<class _RanIt,
	class _Pr>
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred);

template<class _RanIt,
	class _Pr> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	// order Nth element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	_Nth_element(
		_Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last), _Pred);
	}

		// TEMPLATE FUNCTION includes
export
template<class _InIt1,
	class _InIt2>
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2);

template<class _InIt1,
	class _InIt2> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// test if all [_First1, _Last1) in [_First2, _Last2), using operator<
	_DEBUG_ORDER(_First1, _Last1);
	_DEBUG_ORDER(_First2, _Last2);
	return (_Includes(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2)));
	}

		// TEMPLATE FUNCTION includes WITH PRED
export
template<class _InIt1,
	class _InIt2,
	class _Pr>
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred);

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// test if set [_First1, _Last1) in [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	return (_Includes(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		// TEMPLATE FUNCTION set_union
export
template<class _InIt1,
	class _InIt2,
	class _OutIt>
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_Set_union(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_union1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _True_type)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_union1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _False_type)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	_DEBUG_ORDER(_First1, _Last1);
	_DEBUG_ORDER(_First2, _Last2);
	_DEBUG_POINTER(_Dest);
	return (_Set_union1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_union(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION set_union WITH PRED
export
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr>
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_Set_union(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _True_type)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _False_type)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER(_Dest);
	return (_Set_union2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_union(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION set_intersection
export
template<class _InIt1,
	class _InIt2,
	class _OutIt>
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_Set_intersection(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_intersection1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _True_type)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_intersection1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _False_type)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using operator<
	_DEBUG_ORDER(_First1, _Last1);
	_DEBUG_ORDER(_First2, _Last2);
	_DEBUG_POINTER(_Dest);
	return (_Set_intersection1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_intersection(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION set_intersection WITH PRED
export
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr>
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_Set_intersection(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _True_type)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _False_type)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER(_Dest);
	return (_Set_intersection2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_intersection(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION set_difference
export
template<class _InIt1,
	class _InIt2,
	class _OutIt>
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using operator<
	return (_Set_difference(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_difference1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _True_type)
	{	// take set [_First1, _Last1) from[_First2, _Last2), checked dest
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_difference1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _False_type)
	{	// take set [_First1, _Last1) from [_First2, _Last2), unchecked dest
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using operator<
	_DEBUG_ORDER(_First1, _Last1);
	_DEBUG_ORDER(_First2, _Last2);
	_DEBUG_POINTER(_Dest);
	return (_Set_difference1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	// take set [_First2, _Last2) from [_First1, _Last1), array dest
	return (_Unchecked(
		set_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION set_difference WITH PRED
export
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr>
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using _Pred
	return (_Set_difference(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _True_type)
	{	// take set [_First1, _Last1) from [_First2, _Last2), checked dest
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _False_type)
	{	// take set [_First1, _Last1) from [_First2, _Last2), unchecked dest
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER(_Dest);
	return (_Set_difference2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), array dest
	return (_Unchecked(
		set_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION set_symmetric_difference
export
template<class _InIt1,
	class _InIt2,
	class _OutIt>
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_Set_symmetric_difference(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_symmetric_difference1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _True_type)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_symmetric_difference1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _False_type)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	_DEBUG_ORDER(_First1, _Last1);
	_DEBUG_ORDER(_First2, _Last2);
	_DEBUG_POINTER(_Dest);
	return (_Set_symmetric_difference1(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_symmetric_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION set_symmetric_difference WITH PRED
export
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr>
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred);

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_Set_symmetric_difference(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _True_type)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, _False_type)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER(_Dest);
	return (_Set_symmetric_difference2(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_symmetric_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION max_element
export
template<class _FwdIt>
	_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last);

template<class _FwdIt> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{	// find largest element, using operator<
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Max_element(_Unchecked(_First), _Unchecked(_Last))));
	}

		// TEMPLATE FUNCTION max_element WITH PRED
export
template<class _FwdIt,
	class _Pr>
	_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred);

template<class _FwdIt,
	class _Pr> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find largest element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Max_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		// TEMPLATE FUNCTION min_element
export
template<class _FwdIt>
	_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last);

template<class _FwdIt> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{	// find smallest element, using operator<
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Min_element(_Unchecked(_First), _Unchecked(_Last))));
	}

		// TEMPLATE FUNCTION min_element WITH PRED
export
template<class _FwdIt,
	class _Pr>
	_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred);

template<class _FwdIt,
	class _Pr> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Min_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 #if _HAS_CPP0X
		// TEMPLATE FUNCTION minmax_element
export
template<class _FwdIt>
	_STD pair<_FwdIt, _FwdIt>
		_Minmax_element(_FwdIt _First, _FwdIt _Last);

template<class _FwdIt> inline
	_STD pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last)
	{	// find smallest and largest elements, using operator<
	_DEBUG_RANGE(_First, _Last);
	_STD pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
		_Minmax_element(_Unchecked(_First), _Unchecked(_Last)));
	return (_STD pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		// TEMPLATE FUNCTION minmax_element WITH PRED
export
template<class _FwdIt,
	class _Pr>
	_STD pair<_FwdIt, _FwdIt>
		_Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred);

template<class _FwdIt,
	class _Pr> inline
	_STD pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest and largest elements, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	_STD pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
		_Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
	return (_STD pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}
 #endif /* _HAS_CPP0X */

		// TEMPLATE FUNCTION next_permutation
export
template<class _BidIt>
	bool _Next_permutation(_BidIt _First, _BidIt _Last);

template<class _BidIt> inline
	bool next_permutation(_BidIt _First, _BidIt _Last)
	{	// permute and test for pure ascending, using operator<
	_DEBUG_RANGE(_First, _Last);
	return (_Next_permutation(_Unchecked(_First), _Unchecked(_Last)));
	}

		// TEMPLATE FUNCTION next_permutation WITH PRED
export
template<class _BidIt,
	class _Pr>
	bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred);

template<class _BidIt,
	class _Pr> inline
	bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// permute and test for pure ascending, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Next_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		// TEMPLATE FUNCTION prev_permutation
export
template<class _BidIt>
	bool _Prev_permutation(_BidIt _First, _BidIt _Last);

template<class _BidIt> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last)
	{	// reverse permute and test for pure descending, using operator<
	_DEBUG_RANGE(_First, _Last);
	return (_Prev_permutation(_Unchecked(_First), _Unchecked(_Last)));
	}

		// TEMPLATE FUNCTION prev_permutation WITH PRED
export
template<class _BidIt,
	class _Pr>
	bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred);

template<class _BidIt,
	class _Pr> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// reverse permute and test for pure descending, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Prev_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 #if _HAS_TRADITIONAL_STL
		// TEMPLATE FUNCTION count
template<class _InIt,
	class _Ty,
	class _Diff> inline
	void _Count(_InIt _First, _InIt _Last, const _Ty& _Val, _Diff &_Ans)
	{	// count elements that match _Val
	_Diff _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	_Ans = _Count;
	}

template<class _InIt,
	class _Ty,
	class _Diff> inline
	void count(_InIt _First, _InIt _Last, const _Ty& _Val, _Diff &_Ans)
	{	// count elements that match _Val
	_DEBUG_RANGE(_First, _Last);
	_Count(_Unchecked(_First), _Unchecked(_Last), _Val, _Ans);
	}

		// TEMPLATE FUNCTION count_if
template<class _InIt,
	class _Pr,
	class _Diff> inline
	void _Count_if(_InIt _First, _InIt _Last, _Pr _Pred, _Diff &_Ans)
	{	// count elements satisfying _Pred
	_Diff _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			++_Count;
	_Ans = _Count;
	}

template<class _InIt,
	class _Pr,
	class _Diff> inline
	void count_if(_InIt _First, _InIt _Last, _Pr _Pred, _Diff &_Ans)
	{	// count elements satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	_Count_if(_Unchecked(_First), _Unchecked(_Last), _Pred, _Ans);
	}
 #endif /* _HAS_TRADITIONAL_STL */

 #if _HAS_CPP0X
		// TEMPLATE FUNCTIONS is_heap AND is_heap_until
template<class _RanIt,
	class _Diff> inline
	_RanIt _Is_heap_until(_RanIt _First, _RanIt _Last, _Diff *)
	{	// find extent of range that is a heap ordered by operator<
	_Diff _Size = _Last - _First;

	if (2 <= _Size)
		for (_Diff _Off = 0; ++_Off < _Size; )
			if (_DEBUG_LT(*(_First + (_Off - 1) / 2), *(_First + _Off)))
				return (_First + _Off);
	return (_Last);
	}

template<class _RanIt>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last)
	{	// find extent of range that is a heap ordered by operator<
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Is_heap_until(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First))));
	}

template<class _RanIt>
	bool is_heap(_RanIt _First, _RanIt _Last)
	{	// test if range is a heap ordered by operator<
	return (_Is_heap_until(_First, _Last, _Dist_type(_First))
		== _Last);
	}

		// TEMPLATE FUNCTIONS is_heap AND is_heap_until WITH PRED
template<class _RanIt,
	class _Diff,
	class _Pr> inline
	_RanIt _Is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *)
	{	// find extent of range that is a heap ordered by _Pred
	_Diff _Size = _Last - _First;

	if (2 <= _Size)
		for (_Diff _Off = 0; ++_Off < _Size; )
			if (_DEBUG_LT_PRED(_Pred, *(_First + (_Off - 1) / 2),
				*(_First + _Off)))
				return (_First + _Off);
	return (_Last);
	}

template<class _RanIt,
	class _Pr>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// find extent of range that is a heap ordered by _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Is_heap_until(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First))));
	}

template<class _RanIt,
	class _Pr>
	bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// test if range is a heap ordered by _Pred
	return (_Is_heap_until(_First, _Last, _Pred, _Dist_type(_First))
		== _Last);
	}

		// TEMPLATE FUNCTIONS is_sorted AND is_sorted_until
template<class _FwdIt> inline
	_FwdIt _Is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	// find extent of range that is ordered by operator<
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_DEBUG_LT(*_Next, *_First))
			return (_First);
	return (_Last);
	}

template<class _FwdIt> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	// find extent of range that is ordered by operator<
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Is_sorted_until(_Unchecked(_First), _Unchecked(_Last))));
	}

template<class _FwdIt> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last)
	{	// test if range is ordered by operator<
	return (_STD is_sorted_until(_First, _Last) == _Last);
	}

		// TEMPLATE FUNCTIONS is_sorted AND is_sorted_until WITH PRED
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find extent of range that is ordered by predicate
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))
			return (_First);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find extent of range that is ordered by predicate
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Pred);
	return (_Rechecked(_First,
		_Is_sorted_until(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

template<class _FwdIt,
	class _Pr> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// test if range is ordered by predicate
	return (_STD is_sorted_until(_First, _Last, _Pred) == _Last);
	}
 #endif /* _HAS_CPP0X */
_STD_END
#endif /* _ALGORITHM_ */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */

/*
 * Copyright (c) 1992-2010 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.30:0009 */
